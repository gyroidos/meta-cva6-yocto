diff --git a/include/sbi_utils/serial/uart8250.h b/include/sbi_utils/serial/uart8250.h
index 0a1b5d36..3d01ac02 100644
--- a/include/sbi_utils/serial/uart8250.h
+++ b/include/sbi_utils/serial/uart8250.h
@@ -16,7 +16,14 @@ void uart8250_putc(char ch);
 
 int uart8250_getc(void);
 
+void altera_uart_putc(char ch);
+
+int altera_uart_getc(void);
+
 int uart8250_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
 		  u32 reg_width);
 
+int altera_uart_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
+		  u32 reg_width);
+
 #endif
diff --git a/lib/utils/serial/uart8250.c b/lib/utils/serial/uart8250.c
index 9635ba86..2f24f4ea 100644
--- a/lib/utils/serial/uart8250.c
+++ b/lib/utils/serial/uart8250.c
@@ -83,6 +83,22 @@ int uart8250_getc(void)
 	return -1;
 }
 
+void altera_uart_putc(char ch)
+{
+	while (((get_reg(UART_THR_OFFSET+7) << 8) + get_reg(UART_THR_OFFSET+6) ) < 8)
+		;
+
+	set_reg(UART_THR_OFFSET, ch);
+}
+
+int altera_uart_getc(void)
+{
+	if (get_reg(UART_RBR_OFFSET) !=0)
+		return get_reg(UART_RBR_OFFSET);
+	return -1;
+}
+
+
 int uart8250_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
 		  u32 reg_width)
 {
@@ -123,3 +139,18 @@ int uart8250_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
 
 	return 0;
 }
+
+int altera_uart_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
+		  u32 reg_width)
+{
+
+	uart8250_base      = (volatile void *)base;
+	uart8250_reg_shift = reg_shift;
+	uart8250_reg_width = reg_width;
+	uart8250_in_freq   = in_freq;
+	uart8250_baudrate  = baudrate;
+
+
+
+	return 0;
+}
diff --git a/platform/fpga/cva6-altera/config.mk b/platform/fpga/cva6-altera/config.mk
new file mode 100644
index 0000000..3556461
--- /dev/null
+++ b/platform/fpga/cva6-altera/config.mk
@@ -0,0 +1,36 @@
+#
+# SPDX-License-Identifier: BSD-2-Clause
+#
+# Copyright (C) 2019 FORTH-ICS/CARV
+#		Panagiotis Peristerakis <perister@ics.forth.gr>
+#
+
+#for more infos, check out /platform/template/config.mk
+
+PLATFORM_RISCV_XLEN = 64
+
+# Blobs to build
+FW_TEXT_START=0x80000000
+FW_JUMP=n
+
+ifeq ($(PLATFORM_RISCV_XLEN), 32)
+ # This needs to be 4MB aligned for 32-bit support
+ FW_JUMP_ADDR=0x80400000
+ else
+ # This needs to be 2MB aligned for 64-bit support
+ FW_JUMP_ADDR=0x80200000
+ endif
+FW_JUMP_FDT_ADDR=0x82200000
+
+# Firmware with payload configuration.
+FW_PAYLOAD=y
+
+ifeq ($(PLATFORM_RISCV_XLEN), 32)
+# This needs to be 4MB aligned for 32-bit support
+  FW_PAYLOAD_OFFSET=0x400000
+else
+# This needs to be 2MB aligned for 64-bit support
+  FW_PAYLOAD_OFFSET=0x200000
+endif
+FW_PAYLOAD_FDT_ADDR=0x82200000
+FW_PAYLOAD_ALIGN=0x1000
diff --git a/platform/fpga/cva6-altera/objects.mk b/platform/fpga/cva6-altera/objects.mk
new file mode 100644
index 0000000..33fe0a5
--- /dev/null
+++ b/platform/fpga/cva6-altera/objects.mk
@@ -0,0 +1,8 @@
+#
+# SPDX-License-Identifier: BSD-2-Clause
+#
+# Copyright (C) 2019 FORTH-ICS/CARV
+#		Panagiotis Peristerakis <perister@ics.forth.gr>
+#
+
+platform-objs-y += platform.o
\ No newline at end of file
diff --git a/platform/fpga/cva6-altera/platform.c b/platform/fpga/cva6-altera/platform.c
new file mode 100644
index 0000000..a0d13f2
--- /dev/null
+++ b/platform/fpga/cva6-altera/platform.c
@@ -0,0 +1,178 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (C) 2025 PlanV Technologies
+ *				Angela Gonzalez
+ * Adapted from CVA6 platform
+ */
+
+#include <sbi/riscv_asm.h>
+#include <sbi/riscv_encoding.h>
+#include <sbi/riscv_io.h>
+#include <sbi/sbi_console.h>
+#include <sbi/sbi_const.h>
+#include <sbi/sbi_hart.h>
+#include <sbi/sbi_platform.h>
+#include <sbi_utils/fdt/fdt_fixup.h>
+#include <sbi_utils/irqchip/plic.h>
+#include <sbi_utils/serial/uart8250.h>
+#include <sbi_utils/sys/clint.h>
+
+#define CVA6_UART_ADDR			0x10000000
+#define CVA6_UART_FREQ			50000000
+#define CVA6_UART_BAUDRATE			115200
+#define CVA6_UART_REG_SHIFT			0
+#define CVA6_UART_REG_WIDTH			1
+#define CVA6_PLIC_ADDR			0xc000000
+#define CVA6_PLIC_NUM_SOURCES			3
+#define CVA6_HART_COUNT			1
+#define CVA6_CLINT_ADDR			0x2000000
+
+static struct plic_data plic = {
+	.addr = CVA6_PLIC_ADDR,
+	.num_src = CVA6_PLIC_NUM_SOURCES,
+};
+
+static struct clint_data clint = {
+	.addr = CVA6_CLINT_ADDR,
+	.first_hartid = 0,
+   .hart_count = CVA6_HART_COUNT,
+	.has_64bit_mmio = TRUE,
+};
+
+/*
+ * CVA6 platform early initialization.
+ */
+static int cva6_early_init(bool cold_boot)
+{
+	/* For now nothing to do. */
+	return 0;
+}
+
+/*
+ * CVA6 platform final initialization.
+ */
+static int cva6_final_init(bool cold_boot)
+{
+	void *fdt;
+
+	if (!cold_boot)
+		return 0;
+
+	fdt = sbi_scratch_thishart_arg1_ptr();
+	fdt_fixups(fdt);
+
+	return 0;
+}
+
+/*
+ * Initialize the cva6 console.
+ */
+static int cva6_console_init(void)
+{
+	return altera_uart_init(CVA6_UART_ADDR,
+			     CVA6_UART_FREQ,
+			     CVA6_UART_BAUDRATE,
+			     CVA6_UART_REG_SHIFT,
+			     CVA6_UART_REG_WIDTH);
+}
+
+static int plic_cva6_warm_irqchip_init(int m_cntx_id, int s_cntx_id)
+{
+	size_t i, ie_words = CVA6_PLIC_NUM_SOURCES / 32 + 1;
+
+	/* By default, enable all IRQs for M-mode of target HART */
+	if (m_cntx_id > -1) {
+		for (i = 0; i < ie_words; i++)
+			plic_set_ie(&plic, m_cntx_id, i, 1);
+	}
+	/* Enable all IRQs for S-mode of target HART */
+	if (s_cntx_id > -1) {
+		for (i = 0; i < ie_words; i++)
+			plic_set_ie(&plic, s_cntx_id, i, 1);
+	}
+	/* By default, enable M-mode threshold */
+	if (m_cntx_id > -1)
+		plic_set_thresh(&plic, m_cntx_id, 1);
+	/* By default, disable S-mode threshold */
+	if (s_cntx_id > -1)
+		plic_set_thresh(&plic, s_cntx_id, 0);
+
+	return 0;
+}
+
+/*
+ * Initialize the cva6 interrupt controller for current HART.
+ */
+static int cva6_irqchip_init(bool cold_boot)
+{
+	u32 hartid = current_hartid();
+	int ret;
+
+	if (cold_boot) {
+		ret = plic_cold_irqchip_init(&plic);
+		if (ret)
+			return ret;
+	}
+	return plic_cva6_warm_irqchip_init(2 * hartid, 2 * hartid + 1);
+}
+
+/*
+ * Initialize IPI for current HART.
+ */
+static int cva6_ipi_init(bool cold_boot)
+{
+	int ret;
+
+	if (cold_boot) {
+		ret = clint_cold_ipi_init(&clint);
+		if (ret)
+			return ret;
+	}
+
+	return clint_warm_ipi_init();
+}
+
+/*
+ * Initialize cva6 timer for current HART.
+ */
+static int cva6_timer_init(bool cold_boot)
+{
+	int ret;
+
+	if (cold_boot) {
+		ret = clint_cold_timer_init(&clint, NULL);
+		if (ret)
+			return ret;
+	}
+
+	return clint_warm_timer_init();
+}
+
+/*
+ * Platform descriptor.
+ */
+const struct sbi_platform_operations platform_ops = {
+	.early_init = cva6_early_init,
+	.final_init = cva6_final_init,
+	.console_init = cva6_console_init,
+	.console_putc = altera_uart_putc,
+	.console_getc = altera_uart_getc,
+	.irqchip_init = cva6_irqchip_init,
+	.ipi_init = cva6_ipi_init,
+	.ipi_send = clint_ipi_send,
+	.ipi_clear = clint_ipi_clear,
+	.timer_init = cva6_timer_init,
+	.timer_value = clint_timer_value,
+	.timer_event_start = clint_timer_event_start,
+	.timer_event_stop = clint_timer_event_stop,
+};
+
+const struct sbi_platform platform = {
+	.opensbi_version = OPENSBI_VERSION,
+	.platform_version = SBI_PLATFORM_VERSION(0x0, 0x01),
+	.name = "CVA6 RISC-V",
+	.features = SBI_PLATFORM_DEFAULT_FEATURES,
+	.hart_count = CVA6_HART_COUNT,
+	.hart_stack_size = SBI_PLATFORM_DEFAULT_HART_STACK_SIZE,
+	.platform_ops_addr = (unsigned long)&platform_ops
+};
